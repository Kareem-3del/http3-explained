# الحالة

فريق عمل QUIC اشتغل بشراسة من أواخر 2016 على تحديد البروتوكولات وبيقرب من المراحل النهائية وقت الكتابة (يونيو 2020).

خلال 2019 و 2020 كان في عدد متزايد من [اختبارات التشغيل المتبادل مع HTTP/3](https://docs.google.com/spreadsheets/d/1D0tW89vOoaScs3IY9RGC0UesWGAwE6xyLk0l4JtvTVg) و CDNs و Browsers بدأت تطلق دعم أولي - رغم إنه غالباً وراء flags.

في عدد من [implementations QUIC مختلفة مدرجة](https://github.com/quicwg/base-drafts/wiki/Implementations) في صفحات wiki فرق عمل QUIC.

تطبيق QUIC مش سهل والبروتوكول فضل يتحرك ويتغير حتى التاريخ ده.

## Servers

دعم NGINX لـ QUIC و HTTP/3 تحت التطوير و [نسخة preview اتعلنت](https://www.nginx.com/blog/introducing-technology-preview-nginx-support-for-quic-http-3/).

مكانش في تصريحات عامة من ناحية دعم QUIC من Apache.

## Clients

مافيش من vendors المتصفحات الكبيرة شحن أي نسخة، في أي حالة، تقدر تشغل نسخة IETF من QUIC أو HTTP/3.

Google Chrome شحن بـ implementation شغال لنسخة QUIC بتاعة Google من سنين كتيرة وبدأ مؤخراً يدعم نسخة IETF وراء flag. Firefox بنفس الطريقة بيدعم ده وراء flag.

curl شحن أول دعم HTTP/3 تجريبي (draft-22) في إصدار 7.66.0 في 11 سبتمبر 2019. curl بيستخدم يا library Quiche من Cloudflare أو عائلة libraries ngtcp2 عشان يخلص الشغل.

## عقبات التطبيق

QUIC قرر يستخدم TLS 1.3 كأساس لطبقة crypto والأمان عشان يتجنب اختراع حاجة جديدة وبدلاً من كده يعتمد على بروتوكول موثوق وموجود. بس، بينما عمل ده، فريق العمل قرر كمان إنه عشان يبسط استخدام TLS في QUIC فعلاً، لازم يستخدم بس "TLS messages" ومش "TLS records" للبروتوكول.

ده ممكن يبدو تغيير مش مضر، بس ده فعلاً سبب عائق كبير لمطبقين QUIC stack كتير. مكتبات TLS الموجودة اللي بتدعم TLS 1.3 ببساطة مالهاش APIs كفاية تكشف الوظيفة دي وتسمح لـ QUIC يوصل لها. بينما عدة مطبقين QUIC جايين من منظمات أكبر بتشتغل على TLS stack بتاعها بالتوازي، ده مش صحيح لكل حد.

OpenSSL الوزن الثقيل المفتوح المصدر المهيمن مثلاً، مالوش أي API للموضوع ده. الخطة لمعالجة ده يبدو إنها هتحصل في [PR 8797](https://github.com/openssl/openssl/pull/8797) بتاعهم اللي بيهدف يقدم API شبيه جداً لده بتاع BoringSSL.

ده في النهاية كمان هيؤدي لعقبات نشر لأن QUIC stacks هتحتاج يا تبني نفسها على مكتبات TLS تانية، تستخدم OpenSSL build منفصل مpatched أو تتطلب تحديث لنسخة OpenSSL مستقبلية.

## Kernels وحمل CPU

Google و Facebook ذكروا إن نشر QUIC على نطاق واسع بتاعهم يتطلب تقريباً ضعف مقدار CPU عن نفس حمولة traffic لما تخدم HTTP/2 على TLS.

بعض التفسيرات لده تشمل

- أجزاء UDP في أساساً Linux مش محسنة أبداً زي TCP stack، لأنها مش اتستخدمت تقليدياً لنقل عالي السرعة زي ده.

- TCP و TLS offloading للhardware موجودة، بس ده أندر بكتير لـ UDP وأساساً مايوجدش لـ QUIC.

في أسباب نصدق إن الأداء ومتطلبات CPU هتتحسن مع الوقت.

مثال مصري: فكر في الوضع زي إنك بتشتغل نظام توصيل جديد (QUIC) بدل النظام القديم (HTTP/2). في الأول هيكون محتاج شغل ووقود أكتر لأن السوايق مش متعودين والعربيات مش محسنة للطريق الجديد، بس مع الوقت كله هيتحسن.